const cssTask = require('../tasks/cssResolve');
const util = require('../tool/util');
const processFunc = require('../tool/process');
const processConfig = require('../processConfig');

function mutipleCss (options) {
    var task = options.task;
    var changeFiles = options.changeFiles;
    // var cb = options.cb;
    var cache = options.cache;
    util.cache.deepCopy(cache);
    var source = 0;
    var changeFilesArray = [];
    util.each(task, function (deps, rootPath) {
        if (util.isCss(rootPath)) {
            if (changeFiles && changeFiles.uptFiles) {
                var uptFiles = changeFiles.uptFiles;
                var flag = true;
                if (uptFiles.indexOf(rootPath) === -1) {
                    flag = false;
                }
                if (!flag) {
                    return;
                }
                // styl有修改，同时需要替换对应的deps， 所以deps同时也变化
                changeFiles.uptFiles = uptFiles.concat(deps);
                changeFilesArray = changeFiles.uptFiles;
            }
            source++;
            function callback() {
                var caches = util.cache.getCache();
                // 将缓存一次性发给主线程进行缓存
                processFunc.sendMessage(process, {
                    act: processConfig.FINISH,
                    changeFilesArrays: changeFilesArray,
                    cache: caches
                });
            }
            cssTask.cssResolve(deps, rootPath, callback);
        }
    });
}

processFunc.recieveMessage(process, 'message', function (message) {
    if (message.act === processConfig.NORMAL) {
        mutipleCss(message);
    } else if (message.act === processConfig.KILL) {
        process.exit(1);
    }
});

processFunc.recieveMessage(process, 'uncaughtException', function (e) {
    console.log(e);
    // 杀死所有进程
    processFunc.sendMessage(process, {
        act: processConfig.KILL_ALL,
        error: e
    });
    setTimeout(function () {
        process.exit(1);
    }, 50);
});