/**
 * Created by bjhl on 15/12/5.
 */
const feTree = require('fe-tree');
const path = require('path');

const util = require('./util');
const rule = require('fe-tree/lib/rule');
const config = require('../config');
const fileExports = require('./fileExports').getExportsFile();
const requireConfig = require('./requireConfig').getConfig();
const dep = require('./isDep');


var amdConfig = {
    baseUrl: util.fixPath(requireConfig.baseUrl),
    paths: requireConfig.paths || {},
    packages: requireConfig.packages || []
};

if (config.depMap.htmlRules && Array.isArray(config.depMap.htmlRules)) {
    config.depMap.htmlRules.forEach(function (hRule) {
        if (!hRule.match) {
            hRule.match = function (result) {
                var splitPattern = hRule.splitPattern || /['"]/;
                const terms = result.split(splitPattern);
                if (terms.length === 3) {
                    var filePath = terms[1];
                    if (hRule.replacePattern) {
                        filePath = terms[1].replace(hRule.replacePattern, '');
                    }
                    if (dep.isDepExist(filePath)) {
                        return rule.parseAmdDependencies(
                            (hRule.replacePattern ? filePath : result.replace(new RegExp(hRule.pattern + '\\s*='), '')),
                            amdConfig
                        );
                    }
                    return util.addRequireExtName(filePath);
                }
                return false;
            };
        }
        if (hRule.pattern + '' === hRule.pattern) {
            // 字符串
            hRule.pattern = new RegExp(hRule.pattern + '\\s*=\\s*[\'"][^\'"]+[\'"]', 'ig');
        }
    });
}
var htmlRules = config.depMap.htmlRules || '';

const node = (function () {
    try {
        feTree.parse({
            files: fileExports,
            amdConfig: amdConfig,
            htmlRules: htmlRules,
            processDependency: function (dependency, node) {
                var raw = dependency.raw;
                // 过滤依赖
                if (util.isFilterPath(raw) || /^{{\$jssdk_origin}}/ig.test(raw)) {
                    return;
                }
                if (config.depMap.isExcludeRule && config.depMap.isExcludeRule(raw)) {
                    return;
                }
                // 纠正依赖路径 html,css
                if (!dependency.amd) {
                    var fixPathName = util.fixPath(raw, node.file);
                    if (fixPathName !== raw) {
                        dependency.file = fixPathName;
                    }

                    if (!dependency.file && /^(\.\/|[^./])/.test(raw)) {
                        dependency.file = path.join(node.file, '..', raw);
                    }
                }

                var moduleExclude = {
                    jquery: 1,
                    text: 1,
                    tpl: 1,
                    css: 1,
                    js: 1,
                    html: 1
                };

                var rawExclude = {
                    require: 1,
                    exports: 1,
                    module: 1
                };

                if (!moduleExclude[dependency.module] && !rawExclude[dependency.raw]) {
                    return dependency;
                }
            }
        });
    } catch (e) {
        util.errorHandler(e);
    }

    return feTree;
}());

exports.dependencyMap = node.dependencyMap;
exports.reverseDependencyMap = node.reverseDependencyMap;