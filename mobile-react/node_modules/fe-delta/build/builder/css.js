/**
 * @file css统一处理入口
 * Created by bjhl on 16/1/14.
 */
const fork = require('child_process').fork;
const cpus = require('os').cpus();
const path = require('path');
const cssTask = require('../tasks/cssResolve');
const config = require('../config');

const util = require('../tool/util');
const processFunc = require('../tool/process');
const processConfig = require('../processConfig');
const reverseDependencyMap = require('../tool/feTree').reverseDependencyMap;
var workers = {};
var processArray = [];

exports.build = function (changeFiles, cb) {
    if (config.args.total !== 0) {
        var objectIndex = 0;
        var arrayLength = 4;
        for (var j = 0; j < arrayLength; j++) {
            processArray.push({});
        }

        util.each(reverseDependencyMap, function (deps, rootPath) {
            if (util.isCss(rootPath)) {
                processArray[objectIndex++ % arrayLength][rootPath] = deps;
            }
        });
        const createWorker = function (task) {
            var worker = processFunc.initProcess(path.join(__dirname, '../tasks/mutipleCssResolve.js'));
            var finishFlag = 0;
            var finishWriteFlag = 0;
            function sendKillProcess() {
                if (finishFlag && finishWriteFlag) {
                    processFunc.sendMessage(worker, {
                        act: processConfig.KILL
                    });
                }
            }
            const finishFunc = function(message) {
                // 子进程处理完以后，告诉主进程
                var changeFilesArray = message.changeFilesArrays;
                // 对于style的变化，其依赖也要变化
                if (changeFiles && changeFiles.uptFiles) {
                    var uptFilesArray = changeFiles.uptFiles;
                    changeFiles.uptFiles = uptFilesArray.concat(changeFilesArray);
                }
                // 存储子进程传给主进程的缓存
                var caches = message.cache;
                util.cache.deepCopy(caches);
                arrayLength--;
                console.log('finish还剩下' + arrayLength + '个');
                finishFlag = 1;
                sendKillProcess();
                if (!arrayLength) {
                    if (cb) {
                        cb();
                    }
                }
            };

            const finishWriteFunc = function () {
                finishWriteFlag = 1;
                sendKillProcess();
            };
            const killAllFunc = function (message) {
                var error = message.error;
                throw new Error(error);
            };

            const sendInitParams = function () {
                var cache = util.cache.getCache();
                processFunc.sendMessage(worker, {
                    act: processConfig.NORMAL,
                    task: task,
                    cache: cache,
                    changeFiles: changeFiles,
                });
                workers[worker.pid] = worker;
                console.log('Create worker' + worker.pid);
            };

            processFunc.recieveMessage(worker, 'message', function (message) {
                switch (message.act) {
                    case processConfig.FINISH:
                        finishFunc(message);
                        break;
                    case processConfig.FINISH_WRITE:
                        finishWriteFunc();
                        break;
                    case processConfig.KILL_ALL:
                        killAllFunc(message);
                        break;
                    default:
                        return;
                }
            });

            processFunc.recieveMessage(worker, 'exit', function (message) {
                console.log('Worker' + worker.pid + 'exited.');
                delete workers[worker.pid];
            });

            sendInitParams();

        };
        var workersNumber = (objectIndex < 4) ? objectIndex : arrayLength;
        for (var i = 0; i < workersNumber; i++) {
            createWorker(processArray[i]);
        }
    } else {
        var source = 0;
        util.each(reverseDependencyMap, function (deps, rootPath) {
            if (util.isCss(rootPath)) {
                if (changeFiles && changeFiles.uptFiles) {
                    var uptFiles = changeFiles.uptFiles;
                    var flag = true;
                    if (uptFiles.indexOf(rootPath) === -1) {
                        flag = false;
                    }
                    if (!flag) {
                        return;
                    }
                    // styl有修改，同时需要替换对应的deps， 所以deps同时也变化
                    changeFiles.uptFiles = uptFiles.concat(deps);
                }
                source++;
                cssTask.cssResolve(deps, rootPath, cb);
            }
        });
        if (!source && cb) {
            cb();
        }
    }
};
