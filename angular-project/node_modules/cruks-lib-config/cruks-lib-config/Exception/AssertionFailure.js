/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * @license Copyright (c) 2013-2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var Exception = require("cruks-lib-exception").Exception,
    StringBuilder = require("cruks-lib-string-builder").StringBuilder;

/**
 * @access private
 * @param {cruks-lib-config/Exception/AssertionFailure} self current error instance
 * @param {cruks-lib-string-builder/StringBuilder} complementaryMessage
 *     dump of affected item
 * @param {cruks-lib-string-builder/StringBuilder} location
 *     info about item location
 * @param {cruks-lib-string-builder/StringBuilder} explanationMessage
 *     reason for this message to occur
 * @param {cruks-lib-verbosity-indicator/Verbosity} [verbosity]
 *     error messages verbosity
 * @returns {cruks-lib-string-builder/StringBuilder} composed message
 */
function formatExpectationMessage(self, complementaryMessage, location, explanationMessage, verbosity) {
    var message = new StringBuilder(" ", verbosity);

    message.append("expected").append(explanationMessage);
    if (location.isEmpty()) {
        message.append("but got");
    } else {
        message.append("but").append("\"" + location + "\"").append("got");
    }
    message.append(complementaryMessage);

    return message;
}

/**
 * @access private
 * @param {cruks-lib-config/Exception/AssertionFailure} self current error instance
 * @param {String} message to be used as error message
 * @param {*} item item that caused the error
 * @param {cruks-lib-verbosity-indicator/VerbosityIndicator} verbosity
 *     messages eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker traverse tracker
 * @returns {String} composed message
 */
function createExpectationMessage(self, message, item, verbosity, tracker) {
    var explanation,
        itemDescription = new StringBuilder(" ", verbosity).appendDump(item),
        location = new StringBuilder(".", verbosity).appendCollection(tracker.steps);

    if (tracker.reason) {
        explanation = formatExpectationMessage(self, itemDescription, location, tracker.reason, verbosity);
    } else {
        explanation = formatExpectationMessage(self, itemDescription, location, message, verbosity);
    }

    return explanation.toString();
}

/**
 * @auguments cruks-lib-exception/Exception
 * @constructor
 * @param {String} message to be used as error message
 * @param {*} item item that caused the error
 * @param {cruks-lib-verbosity-indicator/VerbosityIndicator} verbosity
 *     messages eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker traverse tracker
 */
function AssertionFailure(message, item, verbosity, tracker) {
    Exception.call(this, createExpectationMessage(this, message, item, verbosity, tracker));

    this.item = item;
    this.tracker = tracker;
    this.verbosity = verbosity;
}
AssertionFailure.prototype = Object.create(Exception.prototype);
AssertionFailure.prototype.constructor = AssertionFailure;

module.exports = AssertionFailure;
