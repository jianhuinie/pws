/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var path = require("path"),
    ArrayObjectTypeAssertion = require(path.join(__dirname, "/Type/Object/Array")),
    Assertion = require(path.join(__dirname, "/../Assertion")),
    AssertionFailureException = require(path.join(__dirname, "/../../Exception/AssertionFailure")),
    IgnoreResult = require(path.join(__dirname, "/../../Result/Ignore")),
    Reference = require(path.join(__dirname, "/../Reference")),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder;

/**
 * @auguments cruks-lib-config/Testable/Assertion
 * @constructor
 * @param {Array} list list of assertions to be checked
 */
function SomeAssertion(list) {
    Assertion.call(this);

    this.array = new ArrayObjectTypeAssertion();
    this.nestedAssertions = this.array.assert(list);
}
SomeAssertion.prototype = Object.create(Assertion.prototype);

SomeAssertion.prototype.canUseOptional = function (item, isOwnProperty) {
    return Assertion.prototype.canUseOptional.call(this, item, isOwnProperty) && !this.hasReference();
};

SomeAssertion.prototype.getExpectationBaseMessage = function (item, verbosity, isNegated) {
    var isFirst = true,
        message,
        messageSeparator;

    if (isNegated) {
        messageSeparator = " nor ";
    } else {
        messageSeparator = " or ";
    }

    message = new StringBuilder(messageSeparator, verbosity);

    this.nestedAssertions.map(function (assertion) {
        var isChunkNegated = false;

        if (isNegated && isFirst) {
            isChunkNegated = true;
        }
        isFirst = false;

        return message.append(assertion.getExpectationMessage(item, verbosity, isChunkNegated));
    });

    return message;
};

SomeAssertion.prototype.hasReference = function () {
    return this.nestedAssertions.some(function (assertion) {
        return assertion instanceof Reference;
    });
};

SomeAssertion.prototype.test = function (item, verbosity, tracker) {
    var i;

    for (i = 0; i < this.nestedAssertions.length; i += 1) {
        try {
            return this.nestedAssertions[i].assert(item, verbosity, tracker);
        } catch (e) {
            if (!(e instanceof AssertionFailureException)) {
                throw e;
            }
        }
    }

    if (this.isOptional()) {
        return new IgnoreResult(item, verbosity, tracker);
    }

    this.throwAssertionFailureException(item, verbosity, tracker);
};

module.exports = SomeAssertion;
