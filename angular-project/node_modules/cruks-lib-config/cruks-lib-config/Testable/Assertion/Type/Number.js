/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var path = require("path"),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder,
    TypeAssertion = require(path.join(__dirname, "/../Type"));

/**
 * @auguments cruks-lib-config/Testable/Assertion/Type
 * @constructor
 */
function NumberAssertion() {
    TypeAssertion.call(this, "number");
}
NumberAssertion.prototype = Object.create(TypeAssertion.prototype);

NumberAssertion.prototype.getExpectationModifierMessage = function (item, verbosity) {
    var ret = new StringBuilder(" and ", verbosity);

    if (this.modifiers.hasOwnProperty("gt")) {
        ret.append(this.getExpectationModifierMessageGt(item, this.modifiers.gt, verbosity));
    }
    if (this.modifiers.hasOwnProperty("lt")) {
        ret.append(this.getExpectationModifierMessageLt(item, this.modifiers.lt, verbosity));
    }
    if (this.modifiers.hasOwnProperty("gte") && this.modifiers.hasOwnProperty("lte")) {
        ret.append(this.getExpectationModifierMessageBetween(item, this.modifiers.gte, this.modifiers.lte, verbosity));
    } else {
        if (this.modifiers.hasOwnProperty("gte")) {
            ret.append(this.getExpectationModifierMessageGte(item, this.modifiers.gte, verbosity));
        }
        if (this.modifiers.hasOwnProperty("lte")) {
            ret.append(this.getExpectationModifierMessageLte(item, this.modifiers.lte, verbosity));
        }
    }

    return ret;
};

/**
 * @param {*} item element to be checked against
 * @param {Number} lower min range number
 * @param {Number} upper max range number
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
NumberAssertion.prototype.getExpectationModifierMessageBetween = function (item, lower, upper, verbosity) {
    return new StringBuilder(" ", verbosity).append("between").appendDump(lower).append("and").appendDump(upper);
};

/**
 * @param {*} item element to be checked against
 * @param {Number} modifier parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
NumberAssertion.prototype.getExpectationModifierMessageGt = function (item, modifier, verbosity) {
    return new StringBuilder(" ", verbosity).append("greater than").appendDump(modifier);
};

/**
 * @param {*} item element to be checked against
 * @param {Number} modifier parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
NumberAssertion.prototype.getExpectationModifierMessageGte = function (item, modifier, verbosity) {
    return new StringBuilder(" ", verbosity).append("greater or equal").appendDump(modifier);
};

/**
 * @param {*} item element to be checked against
 * @param {Number} modifier parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
NumberAssertion.prototype.getExpectationModifierMessageLt = function (item, modifier, verbosity) {
    return new StringBuilder(" ", verbosity).append("less than").appendDump(modifier);
};

/**
 * @param {*} item element to be checked against
 * @param {Number} modifier parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
NumberAssertion.prototype.getExpectationModifierMessageLte = function (item, modifier, verbosity) {
    return new StringBuilder(" ", verbosity).append("less or equal").appendDump(modifier);
};

/**
 * @param {Number} number 'greater than' constraint
 * @returns {cruks-lib-config/Testable/Assertion/Number} chained object
 */
NumberAssertion.prototype.gt = function (number) {
    this.modifiers.gt = number;

    return this;
};

/**
 * @param {Number} number 'greater than or equal' constraint
 * @returns {cruks-lib-config/Testable/Assertion/Number} chained object
 */
NumberAssertion.prototype.gte = function (number) {
    this.modifiers.gte = number;

    return this;
};

/**
 * @param {Number} number 'lesser than' constraint
 * @returns {cruks-lib-config/Testable/Assertion/Number} chained object
 */
NumberAssertion.prototype.lt = function (number) {
    this.modifiers.lt = number;

    return this;
};

/**
 * @param {Number} number 'lesser than or equal' constraint
 * @returns {cruks-lib-config/Testable/Assertion/Number} chained object
 */
NumberAssertion.prototype.lte = function (number) {
    this.modifiers.lte = number;

    return this;
};

/**
 * This is some syntax sugar for 'gte' and 'lte' methods.
 *
 * @param {Number} gte 'greater than or equal' constraint
 * @param {Number} lte 'lesser than or equal' constraint
 * @returns {cruks-lib-config/Testable/Assertion/Number} chained object
 */
NumberAssertion.prototype.range = function (gte, lte) {
    return this.gte(gte).lte(lte);
};

NumberAssertion.prototype.test = function (item, verbosity, tracker) {
    item = TypeAssertion.prototype.test.call(this, item, verbosity, tracker);

    if (isNaN(item)) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    if (!isFinite(item)) {
        // NaN is not finite, thus checking for infinity should be done after
        // checking for NaN
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    if (this.modifiers.hasOwnProperty("gt")) {
        item = this.testGt(item, this.modifiers.gt, verbosity, tracker);
    }
    if (this.modifiers.hasOwnProperty("gte")) {
        item = this.testGte(item, this.modifiers.gte, verbosity, tracker);
    }
    if (this.modifiers.hasOwnProperty("lt")) {
        item = this.testLt(item, this.modifiers.lt, verbosity, tracker);
    }
    if (this.modifiers.hasOwnProperty("lte")) {
        item = this.testLte(item, this.modifiers.lte, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
NumberAssertion.prototype.testGt = function (item, modifier, verbosity, tracker) {
    if (item <= modifier) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
NumberAssertion.prototype.testGte = function (item, modifier, verbosity, tracker) {
    if (item < modifier) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
NumberAssertion.prototype.testLt = function (item, modifier, verbosity, tracker) {
    if (item >= modifier) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
NumberAssertion.prototype.testLte = function (item, modifier, verbosity, tracker) {
    if (item > modifier) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

module.exports = NumberAssertion;
