/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var path = require("path"),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder,
    TypeAssertion = require(path.join(__dirname, "/../Type"));

/**
 * @auguments cruks-lib-config/Testable/Assertion/Type
 * @constructor
 */
function StringAssertion() {
    TypeAssertion.call(this, "string");
}
StringAssertion.prototype = Object.create(TypeAssertion.prototype);

StringAssertion.prototype.getExpectationModifierMessage = function (item, verbosity) {
    var ret = new StringBuilder(" and ", verbosity);

    if (this.modifiers.hasOwnProperty("matching")) {
        ret.append(new StringBuilder(" ", verbosity).append("matching").appendDump(this.modifiers.matching));
    }

    return ret;
};

/**
 * @param {RegExp} regexp regular expression to be used
 * @returns {cruks-lib-config/Testable/Assertion/Type/String} chained object
 */
StringAssertion.prototype.matching = function (regexp) {
    this.modifiers.matching = regexp;

    return this;
};

StringAssertion.prototype.test = function (item, verbosity, tracker) {
    item = TypeAssertion.prototype.test.call(this, item, verbosity, tracker);

    if (this.modifiers.hasOwnProperty("matching")) {
        item = this.testMatching(item, this.modifiers.matching, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
StringAssertion.prototype.testMatching = function (item, modifier, verbosity, tracker) {
    if (modifier.test(item)) {
        return item;
    }

    this.throwAssertionFailureException(item, verbosity, tracker);
};

module.exports = StringAssertion;
