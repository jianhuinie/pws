/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var moment = require("moment"),
    path = require("path"),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder,
    StringTypeAssertion = require(path.join(__dirname, "/../String"));

/**
 * @auguments cruks-lib-config/Testable/Assertion/Type
 * @constructor
 */
function DateStringAssertion() {
    StringTypeAssertion.call(this);
}
DateStringAssertion.prototype = Object.create(StringTypeAssertion.prototype);

/**
 * @param {String} format date format for additional validation
 * @returns {cruks-lib-config/Testable/Assertion/Type/String/Date} chained object
 */
DateStringAssertion.prototype.format = function (format) {
    this.modifiers.format = format;

    return this;
};

DateStringAssertion.prototype.getExpectationBaseMessage = function (item, verbosity) {
    return new StringBuilder(" ", verbosity).append("date");
};

DateStringAssertion.prototype.getExpectationModifierMessage = function (item, verbosity, isNegated) {
    var message = new StringBuilder(" and ", verbosity),
        parentMessage = StringTypeAssertion.prototype.getExpectationModifierMessage.call(this, item, verbosity, isNegated);

    if (isNegated) {
        parentMessage.append("not");
    }

    if (!parentMessage.isEmpty()) {
        message.append(parentMessage);
    }

    if (this.modifiers.hasOwnProperty("format")) {
        message.append(new StringBuilder(" ", verbosity).append("formatted as").appendDump(this.modifiers.format));
    }

    return message;
};

DateStringAssertion.prototype.test = function (item, verbosity, tracker) {
    item = StringTypeAssertion.prototype.test.call(this, item, verbosity, tracker);

    if (!moment(item, this.modifiers.format).isValid()) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

module.exports = DateStringAssertion;
