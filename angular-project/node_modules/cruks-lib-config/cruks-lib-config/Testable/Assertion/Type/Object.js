/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var path = require("path"),
    Assertion = require(path.join(__dirname, "/../../Assertion")),
    ExactAssertion = require(path.join(__dirname, "/../Exact")),
    InstanceOfAssertion = require(path.join(__dirname, "/../InstanceOf")),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder,
    Testable = require(path.join(__dirname, "/../../../Testable")),
    TypeAssertion = require(path.join(__dirname, "/../Type"));

/**
 * @access private
 * @param {cruks-lib-config/Testable/Assertion/Type/Object} self
 *     current object assertion
 * @param {String} explanation complimentary message
 * @param {*} item element to be checked against
 * @param {Object} modifiers parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
function keysIncludsionMessage(self, explanation, item, modifiers, verbosity) {
    var message = new StringBuilder(" ", verbosity);

    message.append(explanation)
        .appendDump(Object.keys(modifiers))
        .update(function (fragment) {
            if (!fragment.strategy.verbosity.isVerbose()) {
                fragment.strategy.verbosity.setVerbose();
            }
        });

    return message;
}

/**
 * @auguments cruks-lib-config/Testable/Assertion/Type
 * @constructor
 */
function ObjectAssertion() {
    TypeAssertion.call(this, "object");

    this.modifiers.doesNotIncludeKeys = {};
    this.modifiers.includesKeys = {};
    this.modifiers.properties = {};
}
ObjectAssertion.prototype = Object.create(TypeAssertion.prototype);

/**
 * @param {String} key name of key to be expected in input object
 * @returns {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.doesNotIncludeKey = function (key) {
    this.modifiers.doesNotIncludeKeys[key] = true;

    return this;
};

/**
 * @param {Array} keys list of expected keys
 * @returns {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.exactKeys = function (keys) {
    this.modifiers.exactKeys = keys;

    return this;
};

ObjectAssertion.prototype.getExpectationModifierMessage = function (item, verbosity) {
    var message = new StringBuilder(" and ", verbosity);

    if (this.modifiers.hasOwnProperty("exactKeys")) {
        message.append(this.getExpectationModifierMessageExactKeys(item, this.modifiers.exactKeys, verbosity));
    }
    if (!this.isEmpty(this.modifiers.doesNotIncludeKeys)) {
        message.append(this.getExpectationModifierMessageDoesNotIncludeKeys(item, this.modifiers.doesNotIncludeKeys, verbosity));
    }
    if (!this.isEmpty(this.modifiers.includesKeys)) {
        message.append(this.getExpectationModifierMessageIncludesKeys(item, this.modifiers.includesKeys, verbosity));
    }
    if (!this.isEmpty(this.modifiers.properties)) {
        message.append(this.getExpectationModifierMessageProperties(item, this.modifiers.properties, verbosity));
    }

    return message;
};

/**
 * @param {*} item element to be checked against
 * @param {Object} modifiers parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
ObjectAssertion.prototype.getExpectationModifierMessageDoesNotIncludeKeys = function (item, modifiers, verbosity) {
    return keysIncludsionMessage(this, "not including keys", item, modifiers, verbosity);
};

/**
 * @param {*} item element to be checked against
 * @param {Object} modifiers parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
ObjectAssertion.prototype.getExpectationModifierMessageExactKeys = function (item, modifiers, verbosity) {
    var message = new StringBuilder(" ", verbosity);

    message.append("with exact keys")
        .appendDump(modifiers)
        .update(function (fragment) {
            if (!fragment.strategy.verbosity.isVerbose()) {
                fragment.strategy.verbosity.setVerbose();
            }
        });

    return message;
};

/**
 * @param {*} item element to be checked against
 * @param {Object} modifiers parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
ObjectAssertion.prototype.getExpectationModifierMessageIncludesKeys = function (item, modifiers, verbosity) {
    return keysIncludsionMessage(this, "including keys", item, modifiers, verbosity);
};

/**
 * @param {*} item element to be checked against
 * @param {Object} modifiers parameters used to modify message
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @returns {cruks-lib-string-builder/StringBuilder} message object
 */
ObjectAssertion.prototype.getExpectationModifierMessageProperties = function (item, modifiers, verbosity) {
    var message = new StringBuilder(" ", verbosity),
        property;

    message.append("with");
    for (property in modifiers) {
        if (modifiers.hasOwnProperty(property)) {
            message.append("\"" + property + "\"").append("of").append(modifiers[property].getExpectationMessage(item, verbosity));
        }
    }

    return message;
};

/**
 * @param {String} key name of key to be expected in input object
 * @returns {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.includesKey = function (key) {
    this.modifiers.includesKeys[key] = true;

    return this;
};

/**
 * @param {Array} keys list of keys to be expected in input object
 * @returns {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.includesKeys = function (keys) {
    var i;

    for (i = 0; i < keys.length; i += 1) {
        this.includesKey(keys[i]);
    }

    return this;
};

ObjectAssertion.prototype.isEmpty = function (item) {
    // item can be null
    if (!item || typeof item === "object" && Object.keys(item).length < 1) {
        return true;
    }

    return TypeAssertion.prototype.isEmpty.call(this, item);
};

/**
 * @param {String} name property name
 * @param {*} value property value
 * @return {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.property = function (name, value) {
    if (!(value instanceof Assertion)) {
        value = new ExactAssertion(value);
    }

    this.modifiers.properties[name] = value;

    return this;
};

ObjectAssertion.prototype.test = function (item, verbosity, tracker) {
    item = TypeAssertion.prototype.test.call(this, item, verbosity, tracker);

    if (this.modifiers.hasOwnProperty("exactKeys")) {
        item = this.testExactKeys(item, this.modifiers.exactKeys, verbosity, tracker);
    }
    if (!this.isEmpty(this.modifiers.doesNotIncludeKeys)) {
        item = this.testDoesNotIncludeKeys(item, this.modifiers.doesNotIncludeKeys, verbosity, tracker);
    }
    if (!this.isEmpty(this.modifiers.includesKeys)) {
        item = this.testIncludesKeys(item, this.modifiers.includesKeys, verbosity, tracker);
    }
    if (!this.isEmpty(this.modifiers.properties)) {
        item = this.testProperties(item, this.modifiers.properties, verbosity, tracker);
    }
    if (!this.isEmpty(this.modifiers.values)) {
        item = this.testValues(item, this.modifiers.values, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
ObjectAssertion.prototype.testDoesNotIncludeKeys = function (item, modifier, verbosity, tracker) {
    var property;

    for (property in modifier) {
        if (modifier.hasOwnProperty(property) && item.hasOwnProperty(property)) {
            this.throwAssertionFailureException(item, verbosity, tracker);
        }
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
ObjectAssertion.prototype.testExactKeys = function (item, modifier, verbosity, tracker) {
    if (!new ExactAssertion(modifier).isPassing(Object.keys(item), verbosity, tracker)) {
        this.throwAssertionFailureException(item, verbosity, tracker);
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
ObjectAssertion.prototype.testIncludesKeys = function (item, modifier, verbosity, tracker) {
    var property;

    for (property in modifier) {
        if (modifier.hasOwnProperty(property) && !item.hasOwnProperty(property)) {
            this.throwAssertionFailureException(item, verbosity, tracker);
        }
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
ObjectAssertion.prototype.testProperties = function (item, modifier, verbosity, tracker) {
    var forked,
        message = this.getExpectationMessage(item, verbosity),
        property;

    for (property in modifier) {
        if (modifier.hasOwnProperty(property)) {
            forked = tracker.fork(property);
            forked.reason = message;

            item[property] = modifier[property].assert(item[property], verbosity, forked);
        }
    }

    return item;
};

/**
 * @param {*} item element to be checked against
 * @param {*} modifier item used as additional assertion checker
 * @param {cruks-lib-verbosity-indicator/Verbosity} verbosity message eloquence
 * @param {cruks-lib-config/TraverseTracker} tracker progress observer
 * @returns {void}
 */
ObjectAssertion.prototype.testValues = function (item, modifier, verbosity, tracker) {
    var keys = {},
        property,
        values = [];

    /*eslint guard-for-in: 0 */

    for (property in item) {
        keys[values.length] = property;
        values.push(item[property]);
    }

    modifier.assert(values, verbosity, tracker.next(function (forked) {
        var step = forked.steps.pop();

        forked.steps.push(keys[step]);
    }));

    return item;
};

/**
 * @param {cruks-lib-config/Testable} expectation object keys validator
 * @return {cruks-lib-config/Testable/Assertion/Type/Object} chained object
 */
ObjectAssertion.prototype.values = function (expectation) {
    this.modifiers.values = new InstanceOfAssertion(Testable).assert(expectation);

    return this;
};

module.exports = ObjectAssertion;
