/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

var path = require("path"),
    CustomAssertion = require(path.join(__dirname, "/Assertion/Custom")),
    ObjectTypeAssertion = require(path.join(__dirname, "/Assertion/Type/Object")),
    StringBuilder = require("cruks-lib-string-builder").StringBuilder,
    TraverseTracker = require("cruks-lib-traverse-tracker").TraverseTracker,
    Testable = require(path.join(__dirname, "/../Testable"));

/**
 * @auguments cruks-lib-config/Testable
 * @constructor
 * @param {String} parameter expected object key
 */
function Reference(parameter) {
    Testable.call(this);

    this.parameter = parameter;
}
Reference.prototype = Object.create(Testable.prototype);

Reference.prototype.assert = function (item, verbosity, tracker) {
    var input;

    if (!(tracker instanceof TraverseTracker)) {
        tracker = new TraverseTracker();
    }

    if (tracker.snapshots.length) {
        // first available snapshot (first item)
        input = tracker.snapshots[0].data;
    } else {
        input = item;
    }

    input = this.expect().assert(input, verbosity, tracker);

    return Testable.prototype.assert.call(this, input, verbosity, tracker);
};

Reference.prototype.expect = function () {
    var that = this;

    return new ObjectTypeAssertion().includesKey(this.parameter).and(new CustomAssertion(function (item) {
        return item[that.parameter];
    }));
};

Reference.prototype.getExpectationMessage = function (item, verbosity, isNegated) {
    var message = new StringBuilder(" ");

    if (isNegated) {
        message.append("missing");
    }

    message.append("reference to").appendDump(this.parameter);

    return message.toString();
};

module.exports = Reference;
