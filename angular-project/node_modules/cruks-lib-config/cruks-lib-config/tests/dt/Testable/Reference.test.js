/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * @license Copyright (c) 2013-2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

/*global describe: false, it: false */

var assert = require("chai").assert,
    AnythingAssertion = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Assertion/Anything"),
    AssertionFailureException = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Exception/AssertionFailure"),
    NumberTypeAssertion = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Assertion/Type/Number"),
    Reference = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Reference"),
    SchemaAssertion = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Assertion/Schema"),
    SomeAssertion = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Assertion/Some"),
    StringTypeAssertion = require(process.env.PACKAGE_ROOT + "/cruks-lib-config/Testable/Assertion/Type/String");

describe("cruks-lib-config/Testable/Reference", function () {
    describe("#assert()", function () {
        it("can be used with other assertions", function () {
            var schema;

            schema = new SchemaAssertion({
                "a": new SchemaAssertion({
                    "b": new SomeAssertion([
                        new Reference("c").and(new NumberTypeAssertion()),
                        new Reference("d").and(new StringTypeAssertion())
                    ])
                }),
                "c": new AnythingAssertion(),
                "d": new AnythingAssertion()
            });

            assert.deepEqual({
                "a": {
                    "b": "d-string"
                },
                "c": "c-string",
                "d": "d-string"
            }, schema.assert({
                    "a": {},
                    "c": "c-string",
                    "d": "d-string"
                }));
        });

        it("allows self-referencing field", function () {
            var schema;

            schema = new SchemaAssertion({
                "a": new Reference("a").and(new NumberTypeAssertion()),
                "b": new SomeAssertion([
                    new Reference("b").and(new StringTypeAssertion()),
                    new Reference("a").and(new NumberTypeAssertion())
                ])
            });

            assert.deepEqual({
                "a": 5,
                "b": 5
            }, schema.assert({
                    "a": 5,
                    "b": 4
                }));
        });

        it("normalizes optional references", function () {
            var schema = new SchemaAssertion({
                "foo": new SomeAssertion([
                    new Reference("foo"),
                    new Reference("bar")
                ]).optional(),
                "bar": new NumberTypeAssertion()
            });

            assert.deepEqual({
                "bar": 5,
                "foo": 5
            }, schema.assert({
                    "bar": 5
                }));
        });

        it("can remain strictly optional", function () {
            var schema = new SchemaAssertion({
                "foo": new SomeAssertion([
                    new Reference("foo").and(new StringTypeAssertion()),
                    new Reference("bar").and(new StringTypeAssertion())
                ]).optional()
            });

            assert.deepEqual({}, schema.assert({}));
        });

        it("references and modifies any future input", function () {
            var ref;

            ref = new Reference("test").assert({
                "test": 4
            });

            assert.strictEqual(4, ref);
        });

        it("fails when given input does not have requested object", function () {
            assert.throws(function () {
                new Reference("foo").assert({
                    "test": 4
                });
            }, AssertionFailureException);
        });
    });

    describe("#normalize()", function () {
        it("adapts input", function () {
            var r = new Reference("foo").normalize(function (item) {
                return item * 2;
            }).assert({
                "foo": 4
            });

            assert.strictEqual(8, r);
        });
    });
});
