/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

/* global describe: false, it: false */

var assert = require("assert"),
    StringBuilder = require(global.paths.root + "/cruks-lib-string-builder/StringBuilder"),
    VerbosityIndicator = require("cruks-lib-verbosity-indicator").VerbosityIndicator;

describe("cruks-lib-string-builder/StringBuilder", function () {
    describe("#append()", function () {
        it("allows lazy string building", function () {
            var sb1 = new StringBuilder(),
                sb2 = new StringBuilder(),
                sb3 = new StringBuilder();

            sb1.append(sb2).append(sb3).append("!");
            sb2.append("A").append("!");

            assert.strictEqual("A!!", sb1.toString());

            sb3.append("B").append("?");

            assert.strictEqual("A!B?!", sb1.toString());
        });
    });

    describe("#appendDump()", function () {
        describe("respects string builder verbosity", function () {
            it("uses normal verbosity", function () {
                var sb = new StringBuilder();

                sb.append(5).appendDump([1, 2, 3], "::");

                assert.strictEqual("5::array", sb.toString());
            });

            it("uses verbose verbosity", function () {
                var sb = new StringBuilder(null, VerbosityIndicator.VERBOSITY_VERBOSE);

                sb.append(5).appendDump([1, 2, 3], "::");

                assert.strictEqual("5::(array)[(number)\"1\",(number)\"2\",(number)\"3\"]", sb.toString());
            });
        });

        it("appends formatted variable dump", function () {
            var sb = new StringBuilder();

            sb.appendDump(5).append("!");

            assert.strictEqual("(number)\"5\"!", sb.toString());
        });

        it("appends formatted dump with custom separator", function () {
            var sb = new StringBuilder();

            sb.append(5).appendDump("test", "::");

            assert.strictEqual("5::(string)\"test\"", sb.toString());
        });

        it("respects quiet verbosity", function () {
            var sb = new StringBuilder(null, VerbosityIndicator.VERBOSITY_QUIET);

            sb.append(5).appendDump([1, 2, 3], "::");

            assert.strictEqual("", sb.toString());
        });
    });

    describe("#appendFormat()", function () {
        it("appends formatted string", function () {
            var sb = new StringBuilder();

            sb.appendFormat("%d", ["5"]).append("!");

            assert.strictEqual("5!", sb.toString());
        });

        it("appends formatted string with custom separator", function () {
            var sb = new StringBuilder();

            sb.appendFormat("%d", ["5"]).append("!").appendFormat("%d %d", ["1", 2], "->");

            assert.strictEqual("5!->1 2", sb.toString());
        });
    });

    describe("#appendCollection()", function () {
        it("appends formatted string", function () {
            var sb = new StringBuilder(".");

            sb.append(1).appendCollection([2, 3]).append(4);

            assert.strictEqual("1.2.3.4", sb.toString());
        });

        it("appends formatted string with custom separator", function () {
            var sb = new StringBuilder(".");

            sb.append(1).appendCollection([2, 3], "->").append(4);

            assert.strictEqual("1->2->3.4", sb.toString());
        });
    });

    describe("#format()", function () {
        it("builds string and then formats it accordingly", function () {
            var sb = new StringBuilder();

            sb.append("%d").append("->").append("%s");

            assert.strictEqual("1->2", sb.format(["1", "2"]));
            assert.strictEqual("4->8", sb.format([4, 8]));
        });
    });

    describe("#isEmpty()", function () {
        it("reports false when there are no fragments inside", function () {
            var sb = new StringBuilder();

            assert.ok(sb.isEmpty());
        });

        it("reports true when there are fragments inside", function () {
            var sb = new StringBuilder();

            sb.append("fragment");

            assert.ok(!sb.isEmpty());
        });
    });

    describe("#toString()", function () {
        it("allows local custom separator", function () {
            var sb = new StringBuilder(".");

            sb.append("a").append("b", "->").append("c");

            assert.strictEqual("a->b.c", sb.toString());
        });

        it("concatenates string with predefined separator", function () {
            var sb = new StringBuilder(".");

            sb.append("a").append("b").append("c");

            assert.strictEqual("a.b.c", sb.toString());
        });
    });

    describe("#update()", function () {
        it("modifies last string fragment", function () {
            var sb = new StringBuilder();

            sb.appendDump([1, [2], false]).update(function (fragment) {
                    fragment.strategy.verbosity.setVerbose();
                }).append("!");

            assert.strictEqual("(array)[(number)\"1\",array,(boolean)\"false\"]!", sb.toString());
        });
    });

    describe("#updateVerbosity()", function () {
        it("modifies last fragment's verbosity", function () {
            var sb = new StringBuilder();

            sb.appendDump([1, [2]]);

            assert.strictEqual("array", sb.toString());

            sb.updateVerbosity(new VerbosityIndicator(VerbosityIndicator.VERBOSITY_VERBOSE));

            assert.strictEqual("(array)[(number)\"1\",array]", sb.toString());

            sb.updateVerbosity(new VerbosityIndicator(VerbosityIndicator.VERBOSITY_VERY_VERBOSE));

            assert.strictEqual("(array)[(number)\"1\",(array)[(number)\"2\"]]", sb.toString());
        });
    });
});
