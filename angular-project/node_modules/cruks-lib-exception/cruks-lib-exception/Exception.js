/**
 * @license Copyright (c) 2014, Cruks
 * For licensing, see LICENSE
 */

"use strict";

/*eslint no-mixed-requires: 0 */

var STACK_SPLIT_PATTERN = "\n",
    _ = require("lodash");

/**
 * @access private
 * @param {cruks-lib-exception/Exception} current exception instance
 * @returns {String} formatted stack trace
 */
function createStackTrace( /* self */ ) {
    var cutFrom,
        previousLimit = Error.stackTraceLimit,
        stack,
        stackOverheadLength;

    Error.stackTraceLimit = Infinity;
    stack = new Error().stack.split(STACK_SPLIT_PATTERN);
    Error.stackTraceLimit = previousLimit;

    cutFrom = _.findLastIndex(stack, function (item) {
        return -1 !== item.indexOf(__filename);
    });

    // +2 because of this function call and child constructor call
    stackOverheadLength = 2;

    return stack.slice(stackOverheadLength)
        .slice(cutFrom, cutFrom + previousLimit)
        .join(STACK_SPLIT_PATTERN);
}

/**
 * @auguments Error
 * @constructor
 * @param {String} message explanation message
 * @param {Error} [previous] error in exception chain
 */
function Exception(message, previous) {
    if (!(this instanceof Exception)) {
        return new TypeError("Exception is a constructor.");
    }

    Error.call(this, message);

    this.message = message;

    this.setPreviousException(previous);
}
Exception.prototype = Object.create(Error.prototype, {
    "name": {
        /**
         * @type {Boolean}
         */
        "configurable": true,

        /**
         * @type {Boolean}
         */
        "enumerable": true,

        /**
         * @returns {String} exception name
         */
        "get": function () {
            return this.constructor.name || Exception.name;
        }
    },
    "stack": {
        /**
         * @type {Boolean}
         */
        "configurable": true,

        /**
         * @type {Boolean}
         */
        "enumerable": true,

        /**
         * @returns {String} stack trace
         */
        "get": function () {
            return this.toString() + createStackTrace(this);
        }
    }
});
Exception.prototype.constructor = Exception;

/**
 * @param {Error} [previous] error in exception chain
 * @returns {void}
 */
Exception.prototype.setPreviousException = function (previous) {
    if (previous) {
        this.previous = previous;
        this.length = previous.length + 1;
    } else {
        this.previous = void 0;
        this.length = 1;
    }
};

/**
 * @returns {String} string error representation
 */
Exception.prototype.toString = function () {
    var ret = Error.prototype.toString.call(this);

    if (this.previous) {
        return ret + "\n" + this.previous.toString();
    }

    return ret;
};

module.exports = Exception;
